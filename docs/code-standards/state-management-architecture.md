# State Management Architecture

> **Decision**: TanStack Query Cache with Custom Hook Abstraction for Real-Time Updates

## Overview

This document defines the official state management architecture for our SaaS application that combines:
- **TanStack Query** (via Orval auto-generated hooks) for HTTP requests
- **SignalR** for real-time WebSocket updates

The chosen approach is **Custom Hook Abstraction** where the TanStack Query cache serves as the single source of truth, with SignalR updates hidden inside reusable hooks.

---

## Architecture Decision

### Why Custom Hook Abstraction?

| Approach | QueryClient Access | True Real-Time | Complexity | Decision |
|----------|-------------------|----------------|------------|----------|
| Redux | Visible everywhere | Yes | High | **Rejected** - Duplicates state |
| useState | N/A | No (loses cache) | Low | **Rejected** - No caching |
| TanStack Query + direct setQueryData | Visible in handlers | Yes | Medium | **Alternative** |
| **Custom Hook Abstraction** | **Hidden in hooks** | **Yes** | **Medium** | **Chosen** |
| Zustand intermediary | Not needed | Yes | High | **Rejected** - Dual state |

### Key Principles

1. **TanStack Query cache is the single source of truth** for all server data
2. **SignalR updates the cache directly** via `queryClient.setQueryData()`
3. **Complexity is hidden** inside reusable hooks - consumers never see `queryClient`
4. **Works with Orval auto-generated hooks** by leveraging their exported query key getters

---

## State Categorization

| State Type | Where It Lives | Examples |
|------------|----------------|----------|
| Server Data | TanStack Query Cache | Templates, users, menus |
| Real-time Updates | TanStack Query Cache (via SignalR) | Row updates, new items |
| UI Preferences | React Context or Zustand (if needed) | Sidebar open, selected rows |
| Form State | React Hook Form | Form inputs, validation |
| Route State | URL/Router | Current page, query params |

---

## Integration with Orval Auto-Generated Hooks

Orval generates hooks in `src/server/autoGeneratedHooks/` with this pattern:

```typescript
// Auto-generated by Orval - DO NOT MODIFY
export const getQuestionerWebQuestionerTemplatesListQueryKey = () => {
  return [`/questionerTemplates/list`] as const;
};

export function useQuestionerWebQuestionerTemplatesList<TData, TError>(...) {
  // Standard TanStack Query hook
}
```

**Key insight**: Orval exports `getXxxQueryKey()` functions that we use for SignalR cache updates.

---

## Implementation Pattern

### 1. SignalR Event Types

```typescript
// src/lib/signalr/types.ts

export const enum SignalREventAction {
  Created = 'created',
  Updated = 'updated',
  Deleted = 'deleted',
}

export interface SignalREntityEvent<T> {
  entityType: string;
  action: SignalREventAction;
  payload: T;
  tenantId: string;
  /** ISO timestamp for conflict resolution */
  timestamp: string;
}

export interface SignalREventConfig<T> {
  /** SignalR event name (e.g., 'TemplateUpdated') */
  event: string;
  /** Function to update existing data with new payload */
  handler: (payload: T, currentData: T[] | undefined) => T[] | undefined;
}
```

### 2. Generic Real-Time Query Hook

This hook wraps any Orval-generated query with SignalR support:

```typescript
// src/lib/signalr/useRealtimeQuery.ts

import { useEffect, useRef } from 'react';
import { useQueryClient, UseQueryResult } from '@tanstack/react-query';
import { useSignalRConnection } from './useSignalRConnection';
import type { SignalREventConfig } from './types';

interface UseRealtimeQueryOptions<TData, TItem> {
  /** The Orval-generated query hook result */
  query: UseQueryResult<TData>;
  /** The query key (use Orval's getXxxQueryKey() function) */
  queryKey: readonly unknown[];
  /** SignalR events to listen for */
  events: SignalREventConfig<TItem>[];
  /** Optional: Extract array from response (for wrapped responses) */
  getItems?: (data: TData) => TItem[];
  /** Optional: Rebuild response with updated items */
  setItems?: (data: TData, items: TItem[]) => TData;
}

/**
 * Wraps an Orval-generated query with real-time SignalR updates.
 * The queryClient access is hidden - consumers just use this hook.
 *
 * @example
 * ```typescript
 * const query = useQuestionerWebQuestionerTemplatesList();
 *
 * return useRealtimeQuery({
 *   query,
 *   queryKey: getQuestionerWebQuestionerTemplatesListQueryKey(),
 *   events: [
 *     {
 *       event: 'TemplateUpdated',
 *       handler: (updated, items) =>
 *         items?.map(t => t.externalId === updated.externalId ? updated : t),
 *     },
 *   ],
 *   getItems: (data) => data.templates ?? [],
 *   setItems: (data, items) => ({ ...data, templates: items }),
 * });
 * ```
 */
export function useRealtimeQuery<TData, TItem extends { externalId: string }>({
  query,
  queryKey,
  events,
  getItems,
  setItems,
}: UseRealtimeQueryOptions<TData, TItem>): UseQueryResult<TData> {
  const queryClient = useQueryClient();
  const connection = useSignalRConnection();
  const eventsRef = useRef(events);
  eventsRef.current = events;

  useEffect(() => {
    if (!connection) return;

    const handlers = eventsRef.current.map(({ event, handler }) => {
      const signalRHandler = (payload: TItem) => {
        queryClient.setQueryData<TData>(queryKey, (oldData) => {
          if (!oldData) return oldData;

          // If getItems/setItems provided, use them for wrapped responses
          if (getItems && setItems) {
            const items = getItems(oldData);
            const updatedItems = handler(payload, items);
            return updatedItems ? setItems(oldData, updatedItems) : oldData;
          }

          // Otherwise assume TData is the array directly
          return handler(payload, oldData as unknown as TItem[]) as unknown as TData;
        });
      };

      connection.on(event, signalRHandler);
      return { event, signalRHandler };
    });

    return () => {
      handlers.forEach(({ event, signalRHandler }) => {
        connection.off(event, signalRHandler);
      });
    };
  }, [connection, queryClient, queryKey, getItems, setItems]);

  return query;
}
```

### 3. Entity-Specific Real-Time Hooks

Create purpose-built hooks for each entity that wrap the Orval hooks:

```typescript
// src/lib/hooks/questioner/useRealtimeTemplates.ts

import {
  useQuestionerWebQuestionerTemplatesList,
  getQuestionerWebQuestionerTemplatesListQueryKey,
} from '@/server/autoGeneratedHooks/questioner/questionertemplates/questionertemplates';
import type {
  QuestionerTemplateDto,
  ListQuestionerTemplatesResponse,
} from '@/server/autoGeneratedHooks/questioner/models';
import { useRealtimeQuery } from '@/lib/signalr/useRealtimeQuery';

/**
 * Real-time enabled questioner templates list.
 * Automatically receives SignalR updates when templates change.
 *
 * @example
 * ```typescript
 * function TemplateList() {
 *   const { data, isLoading } = useRealtimeTemplatesList();
 *   // Data updates automatically when other users make changes
 *   return <Table data={data?.templates} />;
 * }
 * ```
 */
export function useRealtimeTemplatesList() {
  // Use the Orval-generated hook
  const query = useQuestionerWebQuestionerTemplatesList();

  // Wrap with real-time capabilities
  return useRealtimeQuery<ListQuestionerTemplatesResponse, QuestionerTemplateDto>({
    query,
    queryKey: getQuestionerWebQuestionerTemplatesListQueryKey(),
    events: [
      {
        event: 'TemplateCreated',
        handler: (created, items) =>
          items ? [...items, created] : [created],
      },
      {
        event: 'TemplateUpdated',
        handler: (updated, items) =>
          items?.map(t => t.externalId === updated.externalId ? updated : t),
      },
      {
        event: 'TemplateDeleted',
        handler: (deleted, items) =>
          items?.filter(t => t.externalId !== deleted.externalId),
      },
    ],
    // Handle wrapped response structure
    getItems: (data) => data.templates ?? [],
    setItems: (data, templates) => ({ ...data, templates }),
  });
}
```

### 4. SignalR Connection Manager

```typescript
// src/lib/signalr/connectionManager.ts

import * as signalR from '@microsoft/signalr';

let connection: signalR.HubConnection | null = null;
let connectionPromise: Promise<signalR.HubConnection> | null = null;

const RECONNECT_DELAYS_MS = [0, 2000, 5000, 10000, 30000];
const HUB_URL = '/hubs/realtime';

export interface ConnectionOptions {
  accessToken: string;
  tenantId: string;
  onReconnected?: () => void;
  onDisconnected?: (error?: Error) => void;
}

export async function getConnection(
  options: ConnectionOptions
): Promise<signalR.HubConnection> {
  if (connection?.state === signalR.HubConnectionState.Connected) {
    return connection;
  }

  if (connectionPromise) {
    return connectionPromise;
  }

  connectionPromise = createConnection(options);
  return connectionPromise;
}

async function createConnection(
  options: ConnectionOptions
): Promise<signalR.HubConnection> {
  const { accessToken, tenantId, onReconnected, onDisconnected } = options;

  connection = new signalR.HubConnectionBuilder()
    .withUrl(HUB_URL, {
      accessTokenFactory: () => accessToken,
    })
    .withAutomaticReconnect(RECONNECT_DELAYS_MS)
    .configureLogging(signalR.LogLevel.Warning)
    .build();

  connection.onreconnected(async () => {
    // Rejoin tenant group after reconnection
    await connection?.invoke('JoinTenantGroup', tenantId);
    onReconnected?.();
  });

  connection.onclose((error) => {
    onDisconnected?.(error ?? undefined);
  });

  await connection.start();
  await connection.invoke('JoinTenantGroup', tenantId);

  return connection;
}

export async function disconnectSignalR(): Promise<void> {
  if (connection) {
    await connection.stop();
    connection = null;
    connectionPromise = null;
  }
}

export function getConnectionState(): signalR.HubConnectionState | null {
  return connection?.state ?? null;
}
```

### 5. SignalR Connection Hook

```typescript
// src/lib/signalr/useSignalRConnection.ts

import { useEffect, useState, useCallback } from 'react';
import { HubConnection, HubConnectionState } from '@microsoft/signalr';
import { useQueryClient } from '@tanstack/react-query';
import { useAuth } from '@/lib/auth/useAuth';
import { getConnection, disconnectSignalR, getConnectionState } from './connectionManager';

/**
 * Hook to access the SignalR connection.
 * Manages connection lifecycle and reconnection.
 */
export function useSignalRConnection(): HubConnection | null {
  const [connection, setConnection] = useState<HubConnection | null>(null);
  const queryClient = useQueryClient();
  const { accessToken, tenantId, isAuthenticated } = useAuth();

  const handleReconnected = useCallback(() => {
    // Invalidate stale queries after reconnection
    // This ensures we have fresh data if we missed updates while disconnected
    queryClient.invalidateQueries({
      refetchType: 'active',
    });
  }, [queryClient]);

  useEffect(() => {
    if (!isAuthenticated || !accessToken || !tenantId) {
      return;
    }

    let mounted = true;

    const connect = async () => {
      try {
        const conn = await getConnection({
          accessToken,
          tenantId,
          onReconnected: handleReconnected,
        });

        if (mounted) {
          setConnection(conn);
        }
      } catch (error) {
        console.error('Failed to establish SignalR connection:', error);
      }
    };

    connect();

    return () => {
      mounted = false;
    };
  }, [isAuthenticated, accessToken, tenantId, handleReconnected]);

  return connection;
}

/**
 * Hook to get current connection state.
 */
export function useSignalRConnectionState(): HubConnectionState | null {
  const [state, setState] = useState<HubConnectionState | null>(getConnectionState);

  useEffect(() => {
    const interval = setInterval(() => {
      setState(getConnectionState());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return state;
}
```

---

## Usage Examples

### Basic Usage - Component

```typescript
// src/components/TemplateList.tsx

import { useRealtimeTemplatesList } from '@/lib/hooks/questioner/useRealtimeTemplates';

export function TemplateList() {
  // Simply use the real-time hook - all complexity is hidden
  const { data, isLoading, error } = useRealtimeTemplatesList();

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <Table
      data={data?.templates ?? []}
      columns={columns}
      // Rows update automatically via SignalR - no extra code needed!
    />
  );
}
```

### Advanced Usage - Single Item Updates

```typescript
// src/lib/hooks/questioner/useRealtimeTemplate.ts

import {
  useQuestionerWebQuestionerTemplatesGetById,
  getQuestionerWebQuestionerTemplatesGetByIdQueryKey,
} from '@/server/autoGeneratedHooks/questioner/questionertemplates/questionertemplates';
import type { QuestionerTemplateDto } from '@/server/autoGeneratedHooks/questioner/models';
import { useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { useSignalRConnection } from '@/lib/signalr/useSignalRConnection';

/**
 * Real-time enabled single template query.
 */
export function useRealtimeTemplate(externalId: string) {
  const queryClient = useQueryClient();
  const connection = useSignalRConnection();
  const query = useQuestionerWebQuestionerTemplatesGetById(externalId);
  const queryKey = getQuestionerWebQuestionerTemplatesGetByIdQueryKey(externalId);

  useEffect(() => {
    if (!connection) return;

    const handleUpdate = (updated: QuestionerTemplateDto) => {
      // Only update if this is the template we're watching
      if (updated.externalId === externalId) {
        queryClient.setQueryData<QuestionerTemplateDto>(queryKey, updated);
      }
    };

    const handleDelete = (deleted: { externalId: string }) => {
      if (deleted.externalId === externalId) {
        // Invalidate to trigger refetch (will return 404)
        queryClient.invalidateQueries({ queryKey });
      }
    };

    connection.on('TemplateUpdated', handleUpdate);
    connection.on('TemplateDeleted', handleDelete);

    return () => {
      connection.off('TemplateUpdated', handleUpdate);
      connection.off('TemplateDeleted', handleDelete);
    };
  }, [connection, queryClient, queryKey, externalId]);

  return query;
}
```

### Optimistic Updates with Real-Time Confirmation

```typescript
// src/lib/hooks/questioner/useUpdateTemplate.ts

import { useQueryClient } from '@tanstack/react-query';
import {
  useQuestionerWebQuestionerTemplatesUpdate,
  getQuestionerWebQuestionerTemplatesListQueryKey,
  getQuestionerWebQuestionerTemplatesGetByIdQueryKey,
} from '@/server/autoGeneratedHooks/questioner/questionertemplates/questionertemplates';
import type {
  QuestionerTemplateDto,
  ListQuestionerTemplatesResponse,
} from '@/server/autoGeneratedHooks/questioner/models';

/**
 * Update template mutation with optimistic updates.
 * SignalR will broadcast the authoritative update to all clients.
 */
export function useUpdateTemplate() {
  const queryClient = useQueryClient();

  return useQuestionerWebQuestionerTemplatesUpdate({
    mutation: {
      onMutate: async ({ externalId, data }) => {
        // Cancel outgoing refetches
        await queryClient.cancelQueries({
          queryKey: getQuestionerWebQuestionerTemplatesListQueryKey(),
        });

        // Snapshot previous value for rollback
        const previousList = queryClient.getQueryData<ListQuestionerTemplatesResponse>(
          getQuestionerWebQuestionerTemplatesListQueryKey()
        );

        // Optimistically update the list
        queryClient.setQueryData<ListQuestionerTemplatesResponse>(
          getQuestionerWebQuestionerTemplatesListQueryKey(),
          (old) => {
            if (!old?.templates) return old;
            return {
              ...old,
              templates: old.templates.map((t) =>
                t.externalId === externalId ? { ...t, ...data.contents } : t
              ),
            };
          }
        );

        return { previousList };
      },

      onError: (_err, _variables, context) => {
        // Rollback on error
        if (context?.previousList) {
          queryClient.setQueryData(
            getQuestionerWebQuestionerTemplatesListQueryKey(),
            context.previousList
          );
        }
      },

      // onSettled: No need to invalidate!
      // SignalR will broadcast the update to all clients including this one.
      // The real-time hook will receive the authoritative update.
    },
  });
}
```

---

## Backend SignalR Hub Integration

### C# Hub Example

```csharp
// Hubs/RealtimeHub.cs
public class RealtimeHub : Hub
{
    public async Task JoinTenantGroup(string tenantId)
    {
        await Groups.AddToGroupAsync(Context.ConnectionId, $"tenant-{tenantId}");
    }

    public async Task LeaveTenantGroup(string tenantId)
    {
        await Groups.RemoveFromGroupAsync(Context.ConnectionId, $"tenant-{tenantId}");
    }
}
```

### Broadcasting Updates from Services

```csharp
// Services/QuestionerTemplateService.cs
public class QuestionerTemplateService
{
    private readonly IHubContext<RealtimeHub> _hubContext;

    public async Task UpdateTemplateAsync(QuestionerTemplate template)
    {
        // Save to database...

        // Broadcast to all clients in the tenant group
        await _hubContext.Clients
            .Group($"tenant-{template.TenantId}")
            .SendAsync("TemplateUpdated", new
            {
                template.ExternalId,
                template.Name,
                template.Contents,
                template.IsActive,
                template.UpdatedAt,
            });
    }
}
```

---

## Best Practices

### DO

- Use the exported `getXxxQueryKey()` functions from Orval for SignalR updates
- Create entity-specific hooks like `useRealtimeTemplatesList()` for clean API
- Handle reconnection by invalidating active queries
- Include `timestamp` in SignalR events for conflict resolution

### DON'T

- Expose `queryClient` directly in component code
- Modify Orval-generated files (they will be overwritten)
- Create dual state management (Redux + TanStack Query)
- Skip optimistic updates - they provide better UX

---

## File Structure

```
src/
├── lib/
│   ├── signalr/
│   │   ├── types.ts                    # SignalR event types
│   │   ├── connectionManager.ts        # Connection singleton
│   │   ├── useSignalRConnection.ts     # Connection hook
│   │   └── useRealtimeQuery.ts         # Generic wrapper hook
│   └── hooks/
│       ├── questioner/
│       │   ├── useRealtimeTemplates.ts # Entity-specific hooks
│       │   └── useUpdateTemplate.ts    # Mutations with optimistic updates
│       └── onlinemenu/
│           └── useRealtimeMenus.ts
└── server/
    └── autoGeneratedHooks/             # Orval generated (DO NOT MODIFY)
        ├── questioner/
        ├── onlinemenu/
        └── identity/
```

---

## Migration Guide

When adding real-time capabilities to existing pages:

1. **Identify the Orval hook** being used (e.g., `useQuestionerWebQuestionerTemplatesList`)
2. **Create a real-time wrapper** in `src/lib/hooks/{service}/`
3. **Define SignalR events** the hook should listen for
4. **Replace the import** in components from Orval hook to your real-time hook
5. **Add backend broadcasting** in the C# service for create/update/delete operations

---

## Related Documentation

- [API Hooks Guide](./api-hooks-guide.md)
- [Frontend React Standards](./frontend-react.md)
- [Architecture Patterns](./architecture-patterns.md)
