// Code generation helpers for producing TypeScript preset files

import type { FigmaExtraction } from './types';

/** Overrides for a single component section (e.g., badges, buttons) keyed by mode */
export interface ComponentSectionOverrides {
  light: Record<string, Record<string, string> | string>;
  dark: Record<string, Record<string, string> | string>;
  typography?: Record<string, string>;
  padding?: Record<string, string>;
  gap?: string;
  outlineFillOpacity?: string;
}

/** Generate the import block for the preset file */
function generateImports(hasComponentOverrides: boolean): string[] {
  const imports = [
    '// Generated by scripts/figma/generate.ts — DO NOT EDIT MANUALLY',
    '// To regenerate: npm run figma:sync',
    '',
    'import {',
    '  DEFAULT_ANIMATIONS,',
    '  DEFAULT_BORDER_RADIUS,',
    ...(hasComponentOverrides
      ? ['  DEFAULT_COMPONENTS_DARK,', '  DEFAULT_COMPONENTS_LIGHT,']
      : ['  DEFAULT_COMPONENTS,']),
    '  DEFAULT_DARK_MODE,',
    '  DEFAULT_LAYOUT,',
    '  DEFAULT_LIGHT_MODE,',
    '  DEFAULT_NEUTRAL,',
    '  DEFAULT_PRIMARY,',
    '  DEFAULT_SECONDARY,',
    '  DEFAULT_SHADOWS,',
    '  DEFAULT_SPACING,',
    '  DEFAULT_STATUS,',
    '  DEFAULT_TRANSITIONS,',
    '  DEFAULT_TYPOGRAPHY,',
    '  DEFAULT_TYPOGRAPHY_COMPONENTS,',
    "} from '../defaults';",
    '',
    ...(hasComponentOverrides
      ? ["import type { ComponentsConfig, ThemeConfig } from '../types';"]
      : ["import type { ThemeConfig } from '../types';"]),
    '',
  ];

  return imports;
}

function formatObjectLiteral(
  obj: Record<string, string>,
  indent: number,
  spreadBase?: string,
): string {
  const pad = ' '.repeat(indent);
  const spreadLine = spreadBase ? `${pad}  ...${spreadBase},\n` : '';
  const entries = Object.entries(obj)
    .map(([k, v]) => `${pad}  ${k}: '${v}'`)
    .join(',\n');
  return `{\n${spreadLine}${entries},\n${pad}}`;
}

/** Generate FIGMA_COMPONENTS constant with section overrides */
function generateComponentsOverride(
  sections: Record<string, ComponentSectionOverrides>,
): string[] {
  const sectionNames = Object.keys(sections);
  if (sectionNames.length === 0) return [];

  const lines: string[] = ['const FIGMA_COMPONENTS: ComponentsConfig = {'];

  for (const mode of ['light', 'dark'] as const) {
    const defaultName = mode === 'light' ? 'DEFAULT_COMPONENTS_LIGHT' : 'DEFAULT_COMPONENTS_DARK';
    lines.push(`  ${mode}: {`);
    lines.push(`    ...${defaultName},`);

    for (const [section, overrides] of Object.entries(sections)) {
      const modeOverrides = overrides[mode];
      const hasVariantOverrides = modeOverrides && Object.keys(modeOverrides).length > 0;
      const hasTypography = overrides.typography && Object.keys(overrides.typography).length > 0;
      const hasPadding = overrides.padding && Object.keys(overrides.padding).length > 0;
      const hasGap = !!overrides.gap;
      const hasOutlineFillOpacity = !!overrides.outlineFillOpacity;

      if (!hasVariantOverrides && !hasTypography && !hasPadding && !hasGap && !hasOutlineFillOpacity) continue;

      // Compact single-line format for sections with only flat string overrides
      const allFlatStrings = hasVariantOverrides
        && Object.values(modeOverrides).every((v) => typeof v === 'string')
        && !hasTypography && !hasPadding && !hasGap && !hasOutlineFillOpacity;

      if (allFlatStrings) {
        const entries = Object.entries(modeOverrides)
          .map(([k, v]) => `${k}: '${v}'`)
          .join(', ');
        lines.push(`    ${section}: { ...${defaultName}.${section}, ${entries} },`);
        continue;
      }

      lines.push(`    ${section}: {`);
      lines.push(`      ...${defaultName}.${section},`);

      if (hasVariantOverrides) {
        for (const [key, value] of Object.entries(modeOverrides)) {
          if (typeof value === 'object' && value !== null) {
            const spreadBase = `${defaultName}.${section}.${key}`;
            lines.push(`      ${key}: ${formatObjectLiteral(value as Record<string, string>, 6, spreadBase)},`);
          } else {
            lines.push(`      ${key}: '${value}',`);
          }
        }
      }

      if (hasOutlineFillOpacity) {
        lines.push(`      outlineFillOpacity: '${overrides.outlineFillOpacity}',`);
      }

      if (hasGap) lines.push(`      gap: '${overrides.gap}',`);

      if (hasPadding) {
        lines.push(`      padding: ${formatObjectLiteral(overrides.padding!, 6)},`);
      }

      if (hasTypography) {
        lines.push(`      typography: ${formatObjectLiteral(overrides.typography!, 6)},`);
      }

      lines.push('    },');
    }

    lines.push('  },');
  }

  lines.push('};');
  return lines;
}

/** Generate the ThemeConfig export */
function generateThemeExport(
  usedConstants: string[],
  hasComponentOverrides: boolean,
): string[] {
  const pick = (key: string, figma: string, def: string): string =>
    usedConstants.includes(key) ? figma : def;

  const componentsRef = hasComponentOverrides ? 'FIGMA_COMPONENTS' : 'DEFAULT_COMPONENTS';

  return [
    'export const FIGMA_DESIGN_THEME: ThemeConfig = {',
    "  id: 'figmaDesign',",
    "  name: 'Figma Design',",
    `  primary: ${pick('primary', 'FIGMA_PRIMARY', 'DEFAULT_PRIMARY')},`,
    `  secondary: ${pick('secondary', 'FIGMA_SECONDARY', 'DEFAULT_SECONDARY')},`,
    `  neutral: ${pick('neutral', 'FIGMA_NEUTRAL', 'DEFAULT_NEUTRAL')},`,
    `  status: ${pick('status', 'FIGMA_STATUS', 'DEFAULT_STATUS')},`,
    '  layout: DEFAULT_LAYOUT,',
    '  spacing: DEFAULT_SPACING,',
    '  borderRadius: DEFAULT_BORDER_RADIUS,',
    '  shadows: DEFAULT_SHADOWS,',
    '  typography: DEFAULT_TYPOGRAPHY,',
    '  transitions: DEFAULT_TRANSITIONS,',
    '  animations: DEFAULT_ANIMATIONS,',
    `  light: ${pick('light', 'FIGMA_LIGHT_MODE', 'DEFAULT_LIGHT_MODE')},`,
    `  dark: ${pick('dark', 'FIGMA_DARK_MODE', 'DEFAULT_DARK_MODE')},`,
    `  components: ${componentsRef},`,
    '  typographyComponents: DEFAULT_TYPOGRAPHY_COMPONENTS,',
    '};',
    '',
  ];
}

export function generateScaleOverride(
  constName: string,
  defaultName: string,
  overrideValues: Record<string, unknown> | undefined,
): string[] {
  if (!overrideValues || Object.keys(overrideValues).length === 0) return [];

  const entries = Object.entries(overrideValues)
    .map(([k, v]) => `  '${k}': '${v}'`)
    .join(',\n');

  return [`const ${constName} = {`, `  ...${defaultName},`, entries + ',', '};'];
}

export function generateStatusOverride(
  overrideValues: Record<string, unknown> | undefined,
): string[] {
  if (!overrideValues || Object.keys(overrideValues).length === 0) return [];

  const lines: string[] = ['const FIGMA_STATUS = {', '  ...DEFAULT_STATUS,'];

  for (const [statusKey, statusOverrides] of Object.entries(overrideValues)) {
    if (typeof statusOverrides !== 'object' || !statusOverrides) continue;
    const entries = Object.entries(statusOverrides as Record<string, unknown>)
      .map(([k, v]) => `    '${k}': '${v}'`)
      .join(',\n');
    lines.push(`  ${statusKey}: {`, `    ...DEFAULT_STATUS.${statusKey},`, entries + ',', '  },');
  }

  lines.push('};');
  return lines;
}

export function generateModeOverride(
  constName: string,
  defaultName: string,
  overrideValues: Record<string, unknown> | undefined,
): string[] {
  if (!overrideValues || Object.keys(overrideValues).length === 0) return [];

  const lines: string[] = [`const ${constName} = {`];
  const sections = ['backgrounds', 'text', 'borders'] as const;

  for (const section of sections) {
    const sectionOverrides = overrideValues[section] as Record<string, unknown> | undefined;
    if (sectionOverrides && Object.keys(sectionOverrides).length > 0) {
      const entries = Object.entries(sectionOverrides)
        .map(([k, v]) => `    ${k}: '${v}'`)
        .join(',\n');
      lines.push(`  ${section}: {`, `    ...${defaultName}.${section},`, entries + ',', '  },');
    } else {
      lines.push(`  ${section}: ${defaultName}.${section},`);
    }
  }

  lines.push('};');
  return lines;
}

/** Build color/mode overrides and collect which constants were generated */
function generateColorOverrideConstants(
  overrides: Record<string, unknown>,
): { lines: string[]; usedConstants: string[] } {
  const lines: string[] = [];
  const usedConstants: string[] = [];

  const generators: [string, () => string[]][] = [
    ['primary', () => generateScaleOverride('FIGMA_PRIMARY', 'DEFAULT_PRIMARY', overrides['primary'] as Record<string, unknown> | undefined)],
    ['secondary', () => generateScaleOverride('FIGMA_SECONDARY', 'DEFAULT_SECONDARY', overrides['secondary'] as Record<string, unknown> | undefined)],
    ['neutral', () => generateScaleOverride('FIGMA_NEUTRAL', 'DEFAULT_NEUTRAL', overrides['neutral'] as Record<string, unknown> | undefined)],
    ['status', () => generateStatusOverride(overrides['status'] as Record<string, unknown> | undefined)],
    ['light', () => generateModeOverride('FIGMA_LIGHT_MODE', 'DEFAULT_LIGHT_MODE', overrides['light'] as Record<string, unknown> | undefined)],
    ['dark', () => generateModeOverride('FIGMA_DARK_MODE', 'DEFAULT_DARK_MODE', overrides['dark'] as Record<string, unknown> | undefined)],
  ];

  for (const [key, generator] of generators) {
    if (overrides[key]) {
      lines.push(...generator(), '');
      usedConstants.push(key);
    }
  }

  return { lines, usedConstants };
}

/** Generate complete TypeScript preset file content */
export function generatePresetCode(
  extraction: FigmaExtraction,
  colorOverrides: Record<string, unknown>,
  componentSections: Record<string, ComponentSectionOverrides>,
): string {
  const hasComponentOverrides = Object.keys(componentSections).length > 0;
  const importLines = generateImports(hasComponentOverrides);

  importLines.splice(1, 0, `// Source: Figma file ${extraction.fileKey} at ${extraction.extractedAt}`);

  const { lines: colorLines, usedConstants } = generateColorOverrideConstants(colorOverrides);

  const componentLines = hasComponentOverrides
    ? [...generateComponentsOverride(componentSections), '']
    : [];

  const exportLines = generateThemeExport(usedConstants, hasComponentOverrides);

  return [...importLines, ...colorLines, ...componentLines, ...exportLines].join('\n');
}

/** Result of split preset generation — one file per concern */
export interface SplitPresetFiles {
  mainPreset: string;
  components: string;
  componentsLight: string;
  componentsDark: string;
}

/** Generate per-mode component override lines (without wrapper const) */
function generateModeComponentLines(
  mode: 'light' | 'dark',
  sections: Record<string, ComponentSectionOverrides>,
): string[] {
  const defaultName = mode === 'light' ? 'DEFAULT_COMPONENTS_LIGHT' : 'DEFAULT_COMPONENTS_DARK';
  const lines: string[] = [];

  for (const [section, overrides] of Object.entries(sections)) {
    const modeOverrides = overrides[mode];
    const hasVariantOverrides = modeOverrides && Object.keys(modeOverrides).length > 0;
    const hasTypography = overrides.typography && Object.keys(overrides.typography).length > 0;
    const hasPadding = overrides.padding && Object.keys(overrides.padding).length > 0;
    const hasGap = !!overrides.gap;
    const hasOutlineFillOpacity = !!overrides.outlineFillOpacity;

    if (!hasVariantOverrides && !hasTypography && !hasPadding && !hasGap && !hasOutlineFillOpacity) continue;

    const allFlatStrings = hasVariantOverrides
      && Object.values(modeOverrides).every((v) => typeof v === 'string')
      && !hasTypography && !hasPadding && !hasGap && !hasOutlineFillOpacity;

    if (allFlatStrings) {
      const entries = Object.entries(modeOverrides)
        .map(([k, v]) => `${k}: '${v}'`)
        .join(', ');
      lines.push(`  ${section}: { ...${defaultName}.${section}, ${entries} },`);
      continue;
    }

    lines.push(`  ${section}: {`);
    lines.push(`    ...${defaultName}.${section},`);

    if (hasVariantOverrides) {
      for (const [key, value] of Object.entries(modeOverrides)) {
        if (typeof value === 'object' && value !== null) {
          const spreadBase = `${defaultName}.${section}.${key}`;
          lines.push(`    ${key}: ${formatObjectLiteral(value as Record<string, string>, 4, spreadBase)},`);
        } else {
          lines.push(`    ${key}: '${value}',`);
        }
      }
    }

    if (hasOutlineFillOpacity) lines.push(`    outlineFillOpacity: '${overrides.outlineFillOpacity}',`);
    if (hasGap) lines.push(`    gap: '${overrides.gap}',`);
    if (hasPadding) lines.push(`    padding: ${formatObjectLiteral(overrides.padding!, 4)},`);
    if (hasTypography) lines.push(`    typography: ${formatObjectLiteral(overrides.typography!, 4)},`);

    lines.push('  },');
  }

  return lines;
}

/** Generate split preset files (one per concern) to stay under lint line limits */
export function generateSplitPresetCode(
  extraction: FigmaExtraction,
  colorOverrides: Record<string, unknown>,
  componentSections: Record<string, ComponentSectionOverrides>,
): SplitPresetFiles {
  const header = [
    '// Generated by scripts/figma/generate.ts — DO NOT EDIT MANUALLY',
    `// Source: Figma file ${extraction.fileKey} at ${extraction.extractedAt}`,
    '// To regenerate: npm run figma:sync',
    '',
  ];

  const { lines: colorLines, usedConstants } = generateColorOverrideConstants(colorOverrides);

  // --- Components Light ---
  const lightLines = [
    ...header,
    "import { DEFAULT_COMPONENTS_LIGHT } from '../defaults';",
    '',
    "import type { ComponentsConfig } from '../types';",
    '',
    "export const FIGMA_DESIGN_LIGHT: ComponentsConfig['light'] = {",
    '  ...DEFAULT_COMPONENTS_LIGHT,',
    ...generateModeComponentLines('light', componentSections),
    '};',
    '',
  ];

  // --- Components Dark ---
  const darkLines = [
    ...header,
    "import { DEFAULT_COMPONENTS_DARK } from '../defaults';",
    '',
    "import type { ComponentsConfig } from '../types';",
    '',
    "export const FIGMA_DESIGN_DARK: ComponentsConfig['dark'] = {",
    '  ...DEFAULT_COMPONENTS_DARK,',
    ...generateModeComponentLines('dark', componentSections),
    '};',
    '',
  ];

  // --- Components bridge ---
  const bridgeLines = [
    ...header,
    '',
    "import { FIGMA_DESIGN_DARK } from './figmaDesignComponentsDark';",
    "import { FIGMA_DESIGN_LIGHT } from './figmaDesignComponentsLight';",
    '',
    "import type { ComponentsConfig } from '../types';",
    '',
    'export const FIGMA_DESIGN_COMPONENTS: ComponentsConfig = {',
    '  light: FIGMA_DESIGN_LIGHT,',
    '  dark: FIGMA_DESIGN_DARK,',
    '};',
    '',
  ];

  // --- Main preset ---
  const pick = (key: string, figma: string, def: string): string =>
    usedConstants.includes(key) ? figma : def;

  const mainImports = [
    ...header,
    'import {',
    '  DEFAULT_ANIMATIONS,',
    '  DEFAULT_BORDER_RADIUS,',
    '  DEFAULT_DARK_MODE,',
    '  DEFAULT_LAYOUT,',
    '  DEFAULT_LIGHT_MODE,',
    '  DEFAULT_NEUTRAL,',
    '  DEFAULT_PRIMARY,',
    '  DEFAULT_SECONDARY,',
    '  DEFAULT_SHADOWS,',
    '  DEFAULT_SPACING,',
    '  DEFAULT_STATUS,',
    '  DEFAULT_TRANSITIONS,',
    '  DEFAULT_TYPOGRAPHY,',
    '  DEFAULT_TYPOGRAPHY_COMPONENTS,',
    "} from '../defaults';",
    "import { FIGMA_DESIGN_COMPONENTS } from './figmaDesignComponents';",
    '',
    "import type { ThemeConfig } from '../types';",
    '',
  ];

  const mainExport = [
    ...colorLines,
    'export const FIGMA_DESIGN_THEME: ThemeConfig = {',
    "  id: 'figmaDesign',",
    "  name: 'Figma Design',",
    `  primary: ${pick('primary', 'FIGMA_PRIMARY', 'DEFAULT_PRIMARY')},`,
    `  secondary: ${pick('secondary', 'FIGMA_SECONDARY', 'DEFAULT_SECONDARY')},`,
    `  neutral: ${pick('neutral', 'FIGMA_NEUTRAL', 'DEFAULT_NEUTRAL')},`,
    `  status: ${pick('status', 'FIGMA_STATUS', 'DEFAULT_STATUS')},`,
    '  layout: DEFAULT_LAYOUT,',
    '  spacing: DEFAULT_SPACING,',
    '  borderRadius: DEFAULT_BORDER_RADIUS,',
    '  shadows: DEFAULT_SHADOWS,',
    '  typography: DEFAULT_TYPOGRAPHY,',
    '  transitions: DEFAULT_TRANSITIONS,',
    '  animations: DEFAULT_ANIMATIONS,',
    `  light: ${pick('light', 'FIGMA_LIGHT_MODE', 'DEFAULT_LIGHT_MODE')},`,
    `  dark: ${pick('dark', 'FIGMA_DARK_MODE', 'DEFAULT_DARK_MODE')},`,
    '  components: FIGMA_DESIGN_COMPONENTS,',
    '  typographyComponents: DEFAULT_TYPOGRAPHY_COMPONENTS,',
    '};',
    '',
  ];

  return {
    mainPreset: [...mainImports, ...mainExport].join('\n'),
    components: bridgeLines.join('\n'),
    componentsLight: lightLines.join('\n'),
    componentsDark: darkLines.join('\n'),
  };
}
